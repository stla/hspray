(base) stla@Hulk:~$ cd Documents/Haskell/MyPackages/hspray/
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack build
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack build >&1 | tee xclip.txt
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ echo $PATH
/home/stla/anaconda3/bin:/home/stla/anaconda3/condabin:/home/stla/.cabal/bin:/home/stla/.ghcup/bin:/home/stla/.julia/juliaup/bin:/home/stla/.local/bin:/home/stla/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack build
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack install
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack
stack - The Haskell Tool Stack

Usage: stack [--help] [--version] [--numeric-version] [--hpack-numeric-version] 
             [--docker*] [--nix*] 
             [--verbosity VERBOSITY | (-v|--verbose) | --silent] 
             [--[no-]time-in-log] [--[no-]rsl-in-log] [--stack-root STACK-ROOT] 
             [--work-dir WORK-DIR] [--[no-]system-ghc] [--[no-]install-ghc] 
             [--arch ARCH] [--ghc-variant VARIANT] [--ghc-build BUILD] 
             [-j|--jobs JOBS] [--extra-include-dirs DIR] [--extra-lib-dirs DIR] 
             [--custom-preprocessor-extensions EXT] [--with-gcc PATH-TO-GCC] 
             [--with-hpack HPACK] [--[no-]skip-ghc-check] [--[no-]skip-msys] 
             [--local-bin-path DIR] [--setup-info-yaml URL] 
             [--[no-]modify-code-page] [--[no-]allow-different-user] 
             [--[no-]dump-logs] [--color|--colour WHEN] 
             [--snapshot-location-base URL] [--[no-]script-no-run-compile] 
             [--resolver RESOLVER] [--compiler COMPILER] [--[no-]terminal] 
             [--stack-colors|--stack-colours STYLES] [--terminal-width INT] 
             [--stack-yaml STACK-YAML] [--lock-file ARG] COMMAND|FILE

Available options:
  --help                   Show this help text
  --version                Show version
  --numeric-version        Show only version number
  --hpack-numeric-version  Show only hpack's version number
  --docker*                Run 'stack --docker-help' for details
  --nix*                   Run 'stack --nix-help' for details
  --verbosity VERBOSITY    Verbosity: silent, error, warn, info, debug
  -v,--verbose             Enable verbose mode: verbosity level "debug"
  --silent                 Enable silent mode: verbosity level "silent"
  --[no-]time-in-log       Enable/disable inclusion of timings in logs, for the
                           purposes of using diff with logs (default: enabled)
  --[no-]rsl-in-log        Enable/disable inclusion of raw snapshot layer (rsl)
                           in logs (default: disabled)
  --stack-root STACK-ROOT  Absolute path to the global stack root directory
                           (Overrides any STACK_ROOT environment variable)
  --work-dir WORK-DIR      Relative path of work directory (Overrides any
                           STACK_WORK environment variable, default is
                           '.stack-work')
  --[no-]system-ghc        Enable/disable using the system installed GHC (on the
                           PATH) if it is available and its version matches.
                           Disabled by default.
  --[no-]install-ghc       Enable/disable downloading and installing GHC if
                           necessary (can be done manually with stack setup)
                           (default: enabled)
  --arch ARCH              System architecture, e.g. i386, x86_64
  --ghc-variant VARIANT    Specialized GHC variant, e.g. int-native or
                           integersimple (incompatible with --system-ghc)
  --ghc-build BUILD        Specialized GHC build, e.g. 'gmp4' or 'standard'
                           (usually auto-detected)
  -j,--jobs JOBS           Number of concurrent jobs to run
  --extra-include-dirs DIR Extra directories to check for C header files
  --extra-lib-dirs DIR     Extra directories to check for libraries
  --custom-preprocessor-extensions EXT
                           Extensions used for custom preprocessors
  --with-gcc PATH-TO-GCC   Use gcc found at PATH-TO-GCC
  --with-hpack HPACK       Use HPACK executable (overrides bundled Hpack)
  --[no-]skip-ghc-check    Enable/disable skipping the GHC version and
                           architecture check (default: disabled)
  --[no-]skip-msys         Enable/disable skipping the local MSYS installation
                           (Windows only) (default: disabled)
  --local-bin-path DIR     Install binaries to DIR
  --setup-info-yaml URL    Alternate URL or relative / absolute path for stack
                           dependencies
  --[no-]modify-code-page  Enable/disable setting the codepage to support UTF-8
                           (Windows only) (default: enabled)
  --[no-]allow-different-user
                           Enable/disable permission for users other than the
                           owner of the stack root directory to use a stack
                           installation (POSIX only) (default: true inside
                           Docker, otherwise false)
  --[no-]dump-logs         Enable/disable dump the build output logs for local
                           packages to the console (default: dump warning logs)
  --color,--colour WHEN    Specify when to use color in output; WHEN is
                           'always', 'never', or 'auto'. On Windows versions
                           before Windows 10, for terminals that do not support
                           color codes, the default is 'never'; color may work
                           on terminals that support color codes
  --snapshot-location-base URL
                           The base location of LTS/Nightly snapshots
  --[no-]script-no-run-compile
                           Enable/disable the use of options `--no-run
                           --compile` with `stack script` (default: disabled)
  --resolver RESOLVER      Override resolver in project file
  --compiler COMPILER      Use the specified compiler
  --[no-]terminal          Enable/disable overriding terminal detection in the
                           case of running in a false terminal
  --stack-colors,--stack-colours STYLES
                           Specify stack's output styles; STYLES is a
                           colon-delimited sequence of key=value, where 'key' is
                           a style name and 'value' is a semicolon-delimited
                           list of 'ANSI' SGR (Select Graphic Rendition) control
                           codes (in decimal). Use 'stack ls stack-colors
                           --basic' to see the current sequence. In shells where
                           a semicolon is a command separator, enclose STYLES in
                           quotes.
  --terminal-width INT     Specify the width of the terminal, used for
                           pretty-print messages
  --stack-yaml STACK-YAML  Override project stack.yaml file (overrides any
                           STACK_YAML environment variable)
  --lock-file ARG          Specify how to interact with lock files. Default:
                           read/write. If resolver is overridden: read-only

Available commands:
  build                    Build the package(s) in this directory/configuration
  install                  Shortcut for 'build --copy-bins'
  uninstall                Show how to uninstall Stack. This command does not
                           itself uninstall Stack.
  test                     Shortcut for 'build --test'
  bench                    Shortcut for 'build --bench'
  haddock                  Shortcut for 'build --haddock'
  new                      Create a new project from a template. Run `stack
                           templates' to see available templates. Will also
                           initialise if there is no stack.yaml file. Note: you
                           can also specify a local file or a remote URL as a
                           template; or force an initialisation.
  templates                Show how to find templates available for `stack new'.
                           `stack new' can accept a template from a remote
                           repository (default: github), local file or remote
                           URL. Note: this downloads the help file.
  init                     Create stack project config from cabal or hpack
                           package specifications
  setup                    Get the appropriate GHC for your project
  path                     Print out handy path information
  ls                       List command. (Supports snapshots, dependencies,
                           stack's styles and installed tools)
  unpack                   Unpack one or more packages locally
  update                   Update the package index
  upgrade                  Upgrade to the latest stack
  upload                   Upload a package to Hackage
  sdist                    Create source distribution tarballs
  dot                      Visualize your project's dependency graph using
                           Graphviz dot
  ghc                      Run ghc
  hoogle                   Run hoogle, the Haskell API search engine. Use the
                           '-- ARGUMENT(S)' syntax to pass Hoogle arguments,
                           e.g. stack hoogle -- --count=20, or stack hoogle --
                           server --local.
  exec                     Execute a command. If the command is absent, the
                           first of any arguments is taken as the command.
  run                      Build and run an executable. Defaults to the first
                           available executable if none is provided as the first
                           argument.
  ghci                     Run ghci in the context of package(s) (experimental)
  repl                     Run ghci in the context of package(s) (experimental)
                           (alias for 'ghci')
  runghc                   Run runghc
  runhaskell               Run runghc (alias for 'runghc')
  script                   Run a Stack Script
  eval                     Evaluate some haskell code inline. Shortcut for
                           'stack exec ghc -- -e CODE'
  clean                    Delete build artefacts for the project packages.
  purge                    Delete the project stack working directories
                           (.stack-work by default). Shortcut for 'stack clean
                           --full'
  query                    Query general build information (experimental)
  list                     List package id's in snapshot (experimental)
  ide                      IDE-specific commands
  docker                   Subcommands specific to Docker use
  config                   Subcommands for accessing and modifying configuration
                           values
  hpc                      Subcommands specific to Haskell Program Coverage

stack's documentation is available at https://docs.haskellstack.org/
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack clean
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack build
hspray-0.1.0.0: unregistering (local file changes: CHANGELOG.md README.md hspray.cabal src/Hspray.hs)
hspray> configure (lib)
Configuring hspray-0.1.0.0...
hspray> build (lib)
Preprocessing library for hspray-0.1.0.0..
Building library for hspray-0.1.0.0..
[1 of 1] Compiling Hspray

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:83:3: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
83 |   p + q = addSprays p q
   |   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:88:13: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
88 |   lambda *> p = scaleSpray lambda p
   |             ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:91:3: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
91 |   p * q = multSprays p q
   |   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:96:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
96 | (^+^) p q = p AlgAdd.+ q
   |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:100:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
100 | (^-^) p q = p AlgAdd.- q
    |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:104:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
104 | (^*^) p q = p AlgRing.* q
    |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:108:8: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
108 | (^**^) p n = foldl1 (^*^) (replicate n p)
    |        ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:120:15: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
120 | simplifySpray p = HM.mapKeys simplifyPowers p
    |               ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:123:12: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
123 | cleanSpray p = HM.filter (/= AlgAdd.zero) (simplifySpray p)
    |            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:126:11: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
126 | addSprays p q = cleanSpray $ HM.foldlWithKey' f p q
    |           ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:133:19: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
133 | scaleSpray lambda p = cleanSpray $ HM.map (lambda AlgMod.*>) p
    |                   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:143:12: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
143 | multSprays p q = cleanSpray $ HM.fromListWith (AlgAdd.+) prods
    |            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:160:1: warning: [-Wredundant-constraints]
    • Redundant constraint: AlgRing.C a
    • In the type signature for:
           constantSpray :: forall a.
                            (AlgMod.C a a, AlgRing.C a, Eq a) =>
                            a -> Spray a
    |
160 | constantSpray :: (AlgMod.C a a, AlgRing.C a, Eq a) => a -> Spray a
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:169:11: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
169 | evalSpray p xyz = AlgAdd.sum $ map (evalMonomial xyz) (HM.toList p)
    |           ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:172:10: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
172 | identify p = HM.map constantSpray p
    |          ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:176:14: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
176 | composeSpray p newvars = evalSpray (identify p) newvars
    |              ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:192:28: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
192 | prettySpray prettyCoef var p = unpack $ intercalate (pack " + ") stringTerms
    |                            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:204:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p1’
    |
204 | p1 = fromList [([1, 0], 2)]
    | ^^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:207:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p2’
    |
207 | p2 = HM.fromList [(Powers (S.fromList [1, 1]) 2, 3)]
    | ^^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:210:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p’
    |
210 | p = p1 AlgRing.* p2
    | ^
hspray> copy/register
Installing library in /home/stla/Documents/Haskell/MyPackages/hspray/.stack-work/install/x86_64-linux-tinfo6/b49070c880b17e32c46105c33d54344ea334bf809f698de6971e0e5626638eb5/9.0.2/lib/x86_64-linux-ghc-9.0.2/hspray-0.1.0.0-CKZNFOmTXJMEWCeTxRPKmN
Registering library for hspray-0.1.0.0..
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack build >&1 | tee xclip.txt
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack build
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack clean
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack build
hspray-0.1.0.0: unregistering (local file changes: CHANGELOG.md README.md hspray.cabal src/Hspray.hs)
hspray> configure (lib)
Configuring hspray-0.1.0.0...
hspray> build (lib)
Preprocessing library for hspray-0.1.0.0..
Building library for hspray-0.1.0.0..
[1 of 1] Compiling Hspray

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:83:3: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
83 |   p + q = addSprays p q
   |   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:88:13: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
88 |   lambda *> p = scaleSpray lambda p
   |             ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:91:3: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
91 |   p * q = multSprays p q
   |   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:96:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
96 | (^+^) p q = p AlgAdd.+ q
   |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:100:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
100 | (^-^) p q = p AlgAdd.- q
    |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:104:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
104 | (^*^) p q = p AlgRing.* q
    |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:108:8: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
108 | (^**^) p n = foldl1 (^*^) (replicate n p)
    |        ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:120:15: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
120 | simplifySpray p = HM.mapKeys simplifyPowers p
    |               ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:123:12: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
123 | cleanSpray p = HM.filter (/= AlgAdd.zero) (simplifySpray p)
    |            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:126:11: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
126 | addSprays p q = cleanSpray $ HM.foldlWithKey' f p q
    |           ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:133:19: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
133 | scaleSpray lambda p = cleanSpray $ HM.map (lambda AlgMod.*>) p
    |                   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:143:12: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
143 | multSprays p q = cleanSpray $ HM.fromListWith (AlgAdd.+) prods
    |            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:160:1: warning: [-Wredundant-constraints]
    • Redundant constraint: AlgRing.C a
    • In the type signature for:
           constantSpray :: forall a.
                            (AlgMod.C a a, AlgRing.C a, Eq a) =>
                            a -> Spray a
    |
160 | constantSpray :: (AlgMod.C a a, AlgRing.C a, Eq a) => a -> Spray a
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:169:11: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
169 | evalSpray p xyz = AlgAdd.sum $ map (evalMonomial xyz) (HM.toList p)
    |           ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:172:10: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
172 | identify p = HM.map constantSpray p
    |          ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:176:14: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
176 | composeSpray p newvars = evalSpray (identify p) newvars
    |              ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:192:28: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
192 | prettySpray prettyCoef var p = unpack $ intercalate (pack " + ") stringTerms
    |                            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:204:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p1’
    |
204 | p1 = fromList [([1, 0], 2)]
    | ^^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:207:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p2’
    |
207 | p2 = HM.fromList [(Powers (S.fromList [1, 1]) 2, 3)]
    | ^^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:210:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p’
    |
210 | p = p1 AlgRing.* p2
    | ^
hspray> copy/register
Installing library in /home/stla/Documents/Haskell/MyPackages/hspray/.stack-work/install/x86_64-linux-tinfo6/b49070c880b17e32c46105c33d54344ea334bf809f698de6971e0e5626638eb5/9.0.2/lib/x86_64-linux-ghc-9.0.2/hspray-0.1.0.0-CKZNFOmTXJMEWCeTxRPKmN
Registering library for hspray-0.1.0.0..
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ stack build
hspray-0.1.0.0: unregistering (local file changes: src/Hspray.hs)
hspray> build (lib)
Preprocessing library for hspray-0.1.0.0..
Building library for hspray-0.1.0.0..
[1 of 1] Compiling Hspray

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:83:3: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
83 |   p + q = addSprays p q
   |   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:88:13: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
88 |   lambda *> p = scaleSpray lambda p
   |             ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:91:3: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
91 |   p * q = multSprays p q
   |   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:96:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
   |
96 | (^+^) p q = p AlgAdd.+ q
   |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:100:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
100 | (^-^) p q = p AlgAdd.- q
    |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:104:7: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
104 | (^*^) p q = p AlgRing.* q
    |       ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:108:8: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
108 | (^**^) p n = foldl1 (^*^) (replicate n p)
    |        ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:120:15: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
120 | simplifySpray p = HM.mapKeys simplifyPowers p
    |               ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:123:12: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
123 | cleanSpray p = HM.filter (/= AlgAdd.zero) (simplifySpray p)
    |            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:126:11: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
126 | addSprays p q = cleanSpray $ HM.foldlWithKey' f p q
    |           ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:133:19: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
133 | scaleSpray lambda p = cleanSpray $ HM.map (lambda AlgMod.*>) p
    |                   ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:143:12: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
143 | multSprays p q = cleanSpray $ HM.fromListWith (AlgAdd.+) prods
    |            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:169:11: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
169 | evalSpray p xyz = AlgAdd.sum $ map (evalMonomial xyz) (HM.toList p)
    |           ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:172:10: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
172 | identify p = HM.map constantSpray p
    |          ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:176:14: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
176 | composeSpray p newvars = evalSpray (identify p) newvars
    |              ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:192:28: warning: [-Wname-shadowing]
    This binding for ‘p’ shadows the existing binding
      defined at src/Hspray.hs:210:1
    |
192 | prettySpray prettyCoef var p = unpack $ intercalate (pack " + ") stringTerms
    |                            ^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:204:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p1’
    |
204 | p1 = fromList [([1, 0], 2)]
    | ^^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:207:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p2’
    |
207 | p2 = HM.fromList [(Powers (S.fromList [1, 1]) 2, 3)]
    | ^^

/home/stla/Documents/Haskell/MyPackages/hspray/src/Hspray.hs:210:1: warning: [-Wunused-top-binds]
    Defined but not used: ‘p’
    |
210 | p = p1 AlgRing.* p2
    | ^
hspray> copy/register
Installing library in /home/stla/Documents/Haskell/MyPackages/hspray/.stack-work/install/x86_64-linux-tinfo6/b49070c880b17e32c46105c33d54344ea334bf809f698de6971e0e5626638eb5/9.0.2/lib/x86_64-linux-ghc-9.0.2/hspray-0.1.0.0-CKZNFOmTXJMEWCeTxRPKmN
Registering library for hspray-0.1.0.0..
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ brittany --help
NAME

  brittany - haskell source pretty printer

USAGE

  brittany [--config-file PATH] [--indent AMOUNT] [--columns AMOUNT] [--import-col N]
           [--import-as-col N] [--ghc-options STRING] [-v,--verbose] [PATH]
           [-h,--help] [--version] [--license] [--no-user-config] [--dump-config]
           [--dump-annotations] [--dump-ast-unknown] [--dump-ast-full] [--dump-bridoc-raw]
           [--dump-bridoc-alt] [--dump-bridoc-par] [--dump-bridoc-floating] [--dump-bridoc-columns]
           [--dump-bridoc-indent] [--dump-bridoc-final] [--output-on-errors] [--werror]
           [--omit-output-check] [--exactprint-only] [--disable-formatting] [--obfuscate]
           [--suppress-output] [-c,--check-mode] [--write-mode (display|inplace)]
           [help | license]

DESCRIPTION

  Reformats one or more haskell modules. Currently affects only the module head (imports/exports),
  type signatures and function bindings; everything else is left unmodified. Based on
  ghc-exactprint, thus (theoretically) supporting all that ghc does.
  
  Example invocations:
  
    brittany
      read from stdin, output to stdout
  
    brittany --indent=4 --write-mode=inplace *.hs
      run on all modules in current directory (no backup!)
      4 spaces indentation
  
  This program is written carefully and contains safeguards to ensure the output is syntactically
  valid and that no comments are removed. Nonetheless, this is a young project, and there will
  always be bugs, and ensuring that the transformation never changes semantics of the transformed
  source is currently not possible. Please do check the output and do not let brittany override your
  large codebase without having backups.
  
  There is NO WARRANTY, to the extent permitted by law.
  
  This program is free software released under the AGPLv3. For details use the --license flag.
  
  See https://github.com/lspitzner/brittany
  
  Please report bugs at https://github.com/lspitzner/brittany/issues

ARGUMENTS

  --config-file PATH  path to config file
  --indent AMOUNT     spaces per indentation level
  --columns AMOUNT    target max columns (80 is an old default for this)
  --import-col N      column to align import lists at
  --import-as-col N   column to qualified-as module names at
  --dump-config       dump the programs full config (merged commandline + file + defaults)
  --dump-annotations  dump the full annotations returned by ghc-exactprint
  --dump-ast-unknown  dump the ast for any nodes not transformed, but copied as-is by brittany
  --dump-ast-full     dump the full ast
  --dump-bridoc-raw   dump the pre-transformation bridoc
  --dump-bridoc-alt   dump the partially transformed bridoc: after transformation: alt
  --dump-bridoc-par   dump the partially transformed bridoc: after transformation: par
  --dump-bridoc-floating
                      dump the partially transformed bridoc: after transformation: floating
  --dump-bridoc-columns
                      dump the partially transformed bridoc: after transformation: columns
  --dump-bridoc-indent
                      dump the partially transformed bridoc: after transformation: indent
  --dump-bridoc-final dump the post-transformation bridoc
  --output-on-errors  even when there are errors, produce output (or try to to the degree possible)
  --werror            treat warnings as errors
  --omit-output-check omit checking if the output is syntactically valid (debugging)
  --exactprint-only   do not reformat, but exclusively use exactprint to roundtrip (debugging)
  --ghc-options STRING
                      allows to define default language extensions. The parameter is forwarded to
                      ghc.
  --disable-formatting
                      parse, but don't transform the input at all. Useful for inline config for
                      specific modules.
  --obfuscate         apply obfuscator to the output.
  --suppress-output   suppress the regular output, i.e. the transformed haskell source
  -v,--verbose        [currently without effect; TODO]
  -c,--check-mode     check for changes but do not write them out
                      exits with code 0 if no changes necessary, 1 otherwise
                      and print file path(s) of files that have changes to stdout
  --write-mode (display|inplace)
                      display: output for any input(s) goes to stdout
                      inplace: override respective input file (without backup!)
  PATH                paths to input/inout haskell source files

(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ brittany --indent 2 --columns 80 src/Hspray.hs src/Hspray.hs 
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}

module Hspray
  ( fromList
  , lone
  , unitSpray
  , (*^)
  , (^+^)
  , (^-^)
  , (^*^)
  , (^**^)
  , evalSpray
  , composeSpray
  , prettySpray
  ) where
import qualified Algebra.Additive              as AlgAdd
import qualified Algebra.Module                as AlgMod
import qualified Algebra.Ring                  as AlgRing
import           Data.Foldable                  ( toList )
import           Data.Function                  ( on )
import           Data.HashMap.Strict            ( HashMap )
import qualified Data.HashMap.Strict           as HM
import           Data.Hashable
import           Data.List                      ( sortBy )
import qualified Data.Sequence                 as S
import           Data.Sequence                  ( (><)
                                                , Seq
                                                , dropWhileR
                                                , (|>)
                                                )
import           Data.Text                      ( Text
                                                , append
                                                , cons
                                                , intercalate
                                                , pack
                                                , snoc
                                                , unpack
                                                )


infixr 7 *^

infixl 6 ^+^, ^-^

infixl 7 ^*^

infixr 8 ^**^


data Powers = Powers
  { exponents  :: Seq Int
  , nvariables :: Int
  }
  deriving Show

growSequence :: Seq Int -> Int -> Int -> Seq Int
growSequence s m n = s >< t where t = S.replicate (n - m) 0

harmonize :: (Powers, Powers) -> (Powers, Powers)
harmonize (pows1, pows2) = (Powers e1' n, Powers e2' n)
 where
  e1            = exponents pows1
  e2            = exponents pows2
  n1            = nvariables pows1
  n2            = nvariables pows2
  (e1', e2', n) = if n1 < n2
    then (growSequence e1 n1 n2, e2, n2)
    else (e1, growSequence e2 n2 n1, n1)

instance Eq Powers where
  pows1 == pows2 = (exponents pows1') == (exponents pows2')
    where (pows1', pows2') = harmonize (pows1, pows2)

instance Hashable Powers where
  hashWithSalt k pows = hashWithSalt k (exponents pows, nvariables pows)

type Spray a = HashMap Powers a

instance (AlgAdd.C a, Eq a) => AlgAdd.C (Spray a) where
  p + q = addSprays p q
  zero   = HM.empty
  negate = negateSpray

instance (AlgMod.C a a, Eq a) => AlgMod.C a (Spray a) where
  lambda *> p = scaleSpray lambda p

instance (AlgRing.C a, Eq a) => AlgRing.C (Spray a) where
  p * q = multSprays p q
  one = lone 0

-- | Addition of two polynomials
(^+^) :: (AlgAdd.C a, Eq a) => Spray a -> Spray a -> Spray a
(^+^) p q = p AlgAdd.+ q

-- | Substraction
(^-^) :: (AlgAdd.C a, Eq a) => Spray a -> Spray a -> Spray a
(^-^) p q = p AlgAdd.- q

-- | Multiply two polynomials
(^*^) :: (AlgRing.C a, Eq a) => Spray a -> Spray a -> Spray a
(^*^) p q = p AlgRing.* q

-- | Power of a polynomial
(^**^) :: (AlgRing.C a, Eq a) => Spray a -> Int -> Spray a
(^**^) p n = foldl1 (^*^) (replicate n p)

-- | Scale polynomial by a scalar
(*^) :: (AlgMod.C a a, Eq a) => a -> Spray a -> Spray a
(*^) lambda pol = lambda AlgMod.*> pol


simplifyPowers :: Powers -> Powers
simplifyPowers pows = Powers s (S.length s)
  where s = dropWhileR (== 0) (exponents pows)

simplifySpray :: Spray a -> Spray a
simplifySpray p = HM.mapKeys simplifyPowers p

cleanSpray :: (AlgAdd.C a, Eq a) => Spray a -> Spray a
cleanSpray p = HM.filter (/= AlgAdd.zero) (simplifySpray p)

addSprays :: (AlgAdd.C a, Eq a) => Spray a -> Spray a -> Spray a
addSprays p q = cleanSpray $ HM.foldlWithKey' f p q
  where f s powers coef = HM.insertWith (AlgAdd.+) powers coef s

negateSpray :: AlgAdd.C a => Spray a -> Spray a
negateSpray = HM.map AlgAdd.negate

scaleSpray :: (AlgMod.C a a, Eq a) => a -> Spray a -> Spray a
scaleSpray lambda p = cleanSpray $ HM.map (lambda AlgMod.*>) p

multMonomial :: AlgRing.C a => (Powers, a) -> (Powers, a) -> (Powers, a)
multMonomial (pows1, coef1) (pows2, coef2) = (pows, coef1 AlgRing.* coef2)
 where
  (pows1', pows2') = harmonize (pows1, pows2)
  expts            = S.zipWith (+) (exponents pows1') (exponents pows2')
  pows             = Powers expts (nvariables pows1')

multSprays :: (AlgRing.C a, Eq a) => Spray a -> Spray a -> Spray a
multSprays p q = cleanSpray $ HM.fromListWith (AlgAdd.+) prods
 where
  p'    = HM.toList p
  q'    = HM.toList q
  prods = [ multMonomial mp mq | mp <- p', mq <- q' ]

-- | Polynomial x_n
lone :: AlgRing.C a => Int -> Spray a
lone n = HM.singleton pows AlgRing.one
 where
  pows = if n == 0
    then Powers S.empty 0
    else Powers (S.replicate (n - 1) AlgAdd.zero |> AlgRing.one) n

unitSpray :: AlgRing.C a => Spray a
unitSpray = lone 0

constantSpray :: (AlgMod.C a a, Eq a) => a -> Spray a
constantSpray c = c *^ (lone 0)

evalMonomial :: AlgRing.C a => [a] -> (Powers, a) -> a
evalMonomial xyz (powers, coeff) = coeff
  AlgRing.* AlgRing.product (zipWith (AlgRing.^) xyz pows)
  where pows = toList (fromIntegral <$> exponents powers)

evalSpray :: AlgRing.C a => Spray a -> [a] -> a
evalSpray p xyz = AlgAdd.sum $ map (evalMonomial xyz) (HM.toList p)

identify :: (AlgMod.C a a, Eq a) => Spray a -> Spray (Spray a)
identify p = HM.map constantSpray p

composeSpray :: (AlgMod.C a a, Eq a) => Spray a -> [Spray a] -> Spray a
composeSpray p newvars = evalSpray (identify p) newvars

fromList :: (AlgRing.C a, Eq a) => [([Int], a)] -> Spray a
fromList x = cleanSpray $ HM.fromList $ map
  (\(expts, coef) -> (Powers (S.fromList expts) (length expts), coef))
  x

prettyPowers :: String -> [Int] -> Text
prettyPowers var pows = append (pack x) (cons '(' $ snoc string ')')
 where
  x      = " " ++ var ++ "^"
  string = intercalate (pack ", ") (map (pack . show) pows)

-- | Pretty form of a spray
prettySpray :: (a -> String) -> String -> Spray a -> String
prettySpray prettyCoef var p = unpack $ intercalate (pack " + ") stringTerms
 where
  stringTerms = map stringTerm (sortBy (compare `on` fexpts) (HM.toList p))
  fexpts term = exponents $ fst term
  stringTerm term = append
    (snoc (snoc (cons '(' $ snoc stringCoef ')') ' ') '*')
    (prettyPowers var pows)
   where
    pows       = toList $ exponents (fst term)
    stringCoef = pack $ prettyCoef (snd term)

p1 :: Spray Double
p1 = fromList [([1, 0], 2)]

p2 :: Spray Double
p2 = HM.fromList [(Powers (S.fromList [1, 1]) 2, 3)]

p :: Spray Double
p = p1 AlgRing.* p2
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ brittany --indent 2 --columns 80 src/Hspray.hs > src/Hspray.hs 
(base) stla@Hulk:~/Documents/Haskell/MyPackages/hspray$ 
